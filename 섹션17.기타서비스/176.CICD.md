# 🌐 AWS CI/CD 핵심 개념 및 아키텍처 정리

CI/CD는 개발자뿐만 아니라 **솔루션 아키텍트(SA)** 관점에서도 시스템의 자동화와 안정성을 위해 반드시 이해해야 하는 핵심 요소입니다.

---

## 1. 지속적 통합 (CI: Continuous Integration)

개발자가 변경한 코드를 중앙 저장소에 자주 통합하고, 이를 자동으로 빌드 및 테스트하는 과정입니다.

* **핵심 목적:** 코드 결함(버그) 조기 발견, 개발 및 배포 속도 향상, 테스트 자동화를 통한 시간 절약.
* **주요 단계:** 1.  **Code Push:** 개발자가 GitHub, CodeCommit 등에 코드 업로드.
2.  **Build & Test:** 빌드 서버가 코드를 가져와 컴파일 및 유닛 테스트 수행.
3.  **Feedback:** 테스트 통과 여부를 개발자에게 즉시 알림.
* **관련 서비스:** `AWS CodeBuild`, `Jenkins CI` 등.

## 2. 지속적 배포 (CD: Continuous Delivery/Deployment)

빌드된 소프트웨어를 언제든지 안정적으로 사용자에게 릴리스할 수 있도록 배포 과정을 자동화하는 단계입니다.

* **핵심 목적:** 릴리스 주기 단축 (예: 3개월 → 하루 5번), 배포 과정의 휴먼 에러 방지.
* **동작 방식:** CI 단계에서 빌드가 성공하면, 배포 서버가 인프라(EC2, Lambda 등)에 새 버전(v1 → v2)을 자동으로 적용.
* **관련 서비스:** `AWS CodeDeploy`, `Jenkins CD`, `Spinnaker` 등.

---

## 3. AWS CI/CD 기술 스택 (Tooling)

| 단계 | AWS 서비스 | 타사/오픈소스 대안 |
| --- | --- | --- |
| **Code (저장소)** | **CodeCommit** | GitHub, BitBucket |
| **Build & Test** | **CodeBuild** (시간 제한 없음) | Jenkins CI |
| **Deploy (배포)** | **CodeDeploy** | Spinnaker |
| **Provisioning** | **Elastic Beanstalk**, **CloudFormation** | Terraform |
| **Orchestration** | **CodePipeline** (전체 과정 조정) | - |

> **💡 Tip:** CodeBuild는 람다 함수와 달리 실행 시간 제한 측면에서 유리하므로 대규모 빌드/테스트에 적합합니다.

---

## 4. [SA Pro 시험 단골] 기업형 CI/CD 아키텍처

시험에서 중요하게 다루는 **개발(DEV) 및 운영(PROD) 환경 분리** 전략입니다.

### 브랜치 전략 및 파이프라인 구성

* **독립된 환경:** 각 브랜치(DEV, PROD)마다 **별도의 CodePipeline**이 존재해야 합니다.
* **개발 단계:** 1.  `DEV 브랜치`에 푸시 → `DEV 파이프라인` 작동 → `Beanstalk 개발 환경`에 배포.
2.  기능 검증 후 `Pull Request`를 통해 `PROD 브랜치`로 머지(Merge).
* **운영 단계:** 1.  `PROD 브랜치` 머지 발생 → `PROD 파이프라인` 작동 → `Beanstalk 운영 환경`에 최종 배포.

---

## 5. 고급 활용 사례 (Advanced Use Cases)

### A. 보안 강화 (CodeCommit + Lambda)

* 코드가 푸시될 때마다 람다 함수를 트리거하여 **자격 증명(Access Key 등) 유출**을 스캔.
* 유출 감지 시: IAM 키 비활성화 + 저장소 잠금 + SNS 알림 발송.

### B. 도커(Docker) 이미지 자동화

* `CodeBuild`를 사용하여 도커 이미지를 빌드하고, 생성된 이미지를 **Amazon ECR**에 자동으로 푸시하도록 스크립트 구성.

### C. 수동 승인 (Manual Approval)

* 중요한 운영 환경 배포 전, `CodePipeline` 중간에 수동 승인 단계를 추가하여 관리자의 확인 후 배포 진행 가능.

---

## 6. GitHub 연동 방식 비교 (V1 vs V2)

1. **Version 1 (기존 방식):**
* **폴링(Polling):** 파이프라인이 주기적으로 GitHub를 확인 (비효율적).
* **웹훅(Webhook):** GitHub가 변경 시 알림을 보냄 (비교적 효율적).


2. **Version 2 (최신 방식):**
* **CodeStar 소스 연결:** GitHub 앱을 통해 연결하며, 푸시 이벤트가 실시간으로 가장 매끄럽게 전달되는 권장 방식.
